## LAW — Return-Traffic Intelligence Layer

### **LAW RTI-01: Attention Routing Is a Derived, Non-Authoritative Layer**

**Statement:** The Return-Traffic Intelligence (RTI) layer exists to **reduce noise and route attention**, not to create truth, commitments, or outcomes.

RTI operates strictly as a **derived projection** over canonical records. It may summarize, classify, prioritize, and recommend actions, but it **must never** be a source of truth.

This law is a direct extension of:

* AI as **infrastructure, not an actor** 
* “Artifacts are append-only, not mutable state” 
* “Every write attributable to an actor” 
* Tenant isolation 
* Modulation-not-tool-sprawl discipline 

---

### **1) Purpose**

RTI’s only legitimate outputs are:

* **Compression:** “Here’s the smallest truthful summary of what happened.”
* **Filtering:** “Here’s what we safely ignored (and why).”
* **Escalation:** “Here’s what needs human attention now.”
* **Memory:** “Here’s the context from past events that explains this.”

RTI is an *attention firewall*, not an execution plane.

---

### **2) Authority Boundary**

RTI **MUST NOT**:

* mutate canonical artifacts (recordings/transcripts/evidence manifests/outcomes)
* declare agreements, outcomes, or intent on behalf of humans
* issue commitments, persuasion, or negotiation in any channel (UI, email, webhook, CRM note)

(These are prohibited AI functions.) 

RTI **MAY**:

* generate **neutral summaries** requiring human confirmation 
* propose classifications and risk scores as **non-authoritative analysis**
* recommend next actions *as suggestions*, never as commitments

---

### **3) Immutability & Versioning**

All RTI outputs **MUST** be append-only and versioned.

* RTI writes produce **new versions**, never updates in place, mirroring evidence manifest and transcript versioning patterns 
* Each RTI artifact must include:

  * `input_refs` pointing to the canonical artifacts it derived from (calls, recordings, transcripts, alerts, etc.) 
  * `produced_by` (`system|human|model`) and model identifier if relevant 

---

### **4) Explainability Requirement**

Every RTI decision to **escalate** or **suppress** must be explainable with:

* the rule / policy used (“ignored because recurring, low impact, acknowledged historically”)
* the evidence references (input_refs)
* the confidence + uncertainty notes (when applicable)

If RTI cannot explain, it must default to **human review**.

---

### **5) Human Agency Gate**

Any RTI output that would cause an **external side effect** (wake someone, notify a customer, create a CRM activity, trigger a webhook) must satisfy:

* **Human-controlled policy**: a human created or approved the routing rule (or explicitly enabled automated routing).
* **Audit log written** for the side effect action. 

RTI is allowed to *draft*. Humans decide when it *acts*.

(This aligns with your outcome declaration principle: “the system records what happened; the human declares the meaning.”) 

---

### **6) Tenant Isolation**

RTI must preserve tenant isolation at all times:

* RTI outputs are org-scoped and protected by RLS. 
* Cross-org signals may exist only as an **internal overlay** or explicitly shared artifact; never by default.

---

### **7) Operational Failure Semantics**

RTI failures must be recorded as first-class events, not silent drops:

* RTI must write structured errors to `audit_logs` the same way core systems do 
* RTI must never block canonical processing; it is post-execution intelligence (same pattern as scoring/alerts) 

---

### **8) Anti-Sprawl Clause**

RTI must be implemented as:

* a **service layer** consuming canonical artifacts and producing RTI artifacts
* surfaced via existing dashboards/alerts/reports

RTI must NOT introduce a separate “tool” identity. This is consistent with your “modulation, not tool sprawl” architecture rule. 

---

### **9) Acceptance Tests (Release Gate)**

A release is invalid unless it proves:

1. RTI tables are append-only (no UPDATE/DELETE paths)
2. RTI cannot change canonical artifacts
3. Any RTI side effect has an audit log entry with actor attribution 
4. RTI never generates prohibited language (negotiation/persuasion/commitment) 
5. RTI output includes provenance (`input_refs`, version, produced_by) 

---

# Design Plan — Return-Traffic Intelligence Layer

This plan is written to fit your existing structure (calls as root, append-only artifacts, audit logs, alerts, reports). 

## 1) RTI Data Model (New Tables)

### A. `attention_policies` (Human-authored routing rules)

* org-scoped, versioned
* examples:

  * quiet hours
  * escalation thresholds
  * “ignore recurring alert X unless Y”

**Fields**

* `id`, `organization_id`
* `name`, `description`
* `enabled`
* `policy_json` (rule DSL, versioned)
* `created_by`, `created_at`

### B. `attention_events` (Append-only stream of “return traffic”)

This is the normalized inbox feed.

**Event sources**

* call completed
* evidence bundle generated
* alert triggered
* campaign run ended
* webhook delivery failed
* carrier_status degraded

(You already have `alerts`, `webhook_deliveries`, `carrier_status`, campaigns, reports, etc.) 

**Fields**

* `id`, `organization_id`
* `event_type` (call|alert|integration|campaign|system)
* `source_table`, `source_id`
* `occurred_at` (server)
* `payload_snapshot` (immutable, for later explainability)
* `input_refs` (canonical refs)

### C. `attention_decisions` (Escalate / Suppress / Digest)

This is the RTI “judgment log”, append-only.

**Fields**

* `id`, `organization_id`
* `attention_event_id`
* `decision` (`escalate|suppress|include_in_digest|needs_review`)
* `reason` (short human-readable)
* `policy_id` (what rule caused it)
* `confidence`, `uncertainty_notes`
* `produced_by` (`system|human|model`)
* `produced_by_model` (if model)
* `created_at`

### D. `digests` + `digest_items` (Morning brief / overnight summary)

* digests are generated at set times or on demand
* items reference decisions and events
* immutable: new digest = new row, never “edit yesterday’s”

---

## 2) RTI Processing Pipeline (How it runs)

### Step 1 — Normalize return traffic → `attention_events`

Triggered by:

* webhook handlers
* post-processing completions
* scheduled jobs (existing cron concept)

### Step 2 — Apply policies → produce `attention_decisions`

* evaluate each new attention_event against org policies
* attach rule + explanation
* if ambiguity: `needs_review`

### Step 3 — Side effects (optional)

Only if policy allows + audited:

* send SMS/email
* create Slack/Teams webhook delivery
* create CRM note that links to evidence bundle (never overwrites artifacts)

Every side effect writes an `audit_logs` entry. 

### Step 4 — Digest generation

* “Nothing woke you up because nothing important happened.”
* digest includes:

  * “What happened”
  * “What we ignored (and why)”
  * “What needs action now”

---

## 3) UX Surfaces (Minimal, non-sprawling)

### A. “Attention” tab in Analytics / Dashboard (not a new product area)

* Inbox list (events + decisions)
* Filters: escalated / suppressed / needs review
* Drill down shows:

  * linked canonical artifacts
  * reason + policy + provenance

### B. Policy editor (Admin only)

* template-based rules first (no giant DSL UI at v1)
* “quiet hours” + threshold rules + recurring suppression

---

## 4) Guardrails (So it doesn’t drift into “AI decides”)

1. RTI can **draft reasons**, but must not use commitment language (hard filter based on AI Role Policy prohibitions). 
2. Any “this matters” decision must include:

   * the policy
   * the evidence refs
3. Anything that touches external systems requires:

   * explicit admin policy enablement
   * audit log

---

## 5) Build Order (Highest First-Time Success)

1. **Tables + RLS + immutability triggers** (foundation)
2. `attention_events` emission from 3 sources:

   * alerts triggered
   * webhook delivery failures
   * call completion
3. Policy evaluation engine (simple rules)
4. Digests (overnight brief)
5. Optional: model-assisted classification (strictly non-authoritative)

---

If you want, I’ll also write the **Gemini 3 “build prompt pack”** specifically for RTI (migrations + RLS + services + endpoints + tests), in the same style as the immutable search/entity/CRM prompt packs—so you can hand it off and expect a high first-pass hit rate.
