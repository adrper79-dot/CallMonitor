# SWML

Build powerful communication applications with the SignalWire Markup Language

<br />

<br />

SWML is a markup and scripting language for quickly writing powerful communication applications in YAML or JSON documents. SWML is easy to use, and enables you to create powerful voice and messaging applications using a descriptive format.

SWML scripts can be deployed serverlessly via the SignalWire Dashboard, via your own server, or using the [Agents SDK](/sdks/agents-sdk.md). For a comprehensive breakdown, see our [SWML deployment guide](/swml/guides/deployment.md).

* **Server or serverless**: Serve SWML from your own server or via the SignalWire platform
* **Powerful**: Handle voice calls, messaging, AI agents, and more
* **Simple**: Declarative, composable format that's easy to learn, maintain, and scale
* **Extensible**: Integrate native AI, functions, and external APIs

Whether you're building simple call forwarding systems or complex AI-powered customer service agents, SWML provides the tools you need to deploy sophisticated communication workflows.

## Core concepts[​](#core-concepts "Direct link to Core concepts")

### Document structure[​](#document-structure "Direct link to Document structure")

Every SWML script follows this basic structure in either YAML or JSON format:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - method1: {}
    - method2:
        parameter: value

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "method1": {}
      },
      {
        "method2": {
          "parameter": "value"
        }
      }
    ]
  }
}

```

| Properties | Description                                      |
| ---------- | ------------------------------------------------ |
| `version`  | Always use `1.0.0` (the only supported version)  |
| `sections` | Contains all script sections                     |
| `main`     | Required starting section where execution begins |

### Sections[​](#sections "Direct link to Sections")

**Sections** are named blocks of code that organize your script. Each section is an array of [methods](/swml/methods.md) to execute.

All SWML scripts start with the `main` section, but you can create additional sections for different tasks (like `sales`, `support`, `menu`). Use the following methods to move between sections:

* **[`execute`](/swml/methods/execute.md)**: Calls a section like a function and returns to the current section
* **[`transfer`](/swml/methods/transfer.md)**: Transfers control permanently to another section

### Methods[​](#methods "Direct link to Methods")

[Methods](/swml/methods.md) are the commands that tell SWML what to do during a call - like answering, playing audio, collecting input, or instantiating an AI Agent. Think of them as the instructions in your script.

## Basic SWML examples[​](#basic-swml-examples "Direct link to Basic SWML examples")

Here are some basic SWML examples utilizing these core concepts for Text to Speech and Call Forwarding:

* Text to Speech
* Call Forwarding

Create a simple text-to-speech greeting:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - play:
        url: "say:Hello from Signal Wire! Have a great day!"
    - hangup

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "play": {
          "url": "say:Hello from Signal Wire! Have a great day!"
        }
      },
      "hangup"
    ]
  }
}

```

This script will answer the incoming call, play a greeting message using text-to-speech, and then hang up.

Forward incoming calls to another number:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - connect:
        to: "+18888888888"

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "connect": {
          "to": "+18888888888"
        }
      }
    ]
  }
}

```

This script will forward the incoming call to the specified phone number.

## Basic IVR[​](#basic-ivr "Direct link to Basic IVR")

An Interactive Voice Response (IVR) system routes callers to different departments based on their input. This example demonstrates a complete IVR that answers the call, plays a welcome message, records the conversation, collects user input (via keypress or speech), and routes callers to sales or support.

This pattern is one of the most common use cases for SWML and demonstrates how multiple methods work together to create a professional phone system. For an extensive breakdown of this example, see our [IVR Creation Guide](/swml/guides/creating_ivr.md).

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - answer: {}
    - play:
        url: "say:Welcome to Acme Corporation. This call may be recorded."
    - record_call:
        stereo: true
        format: wav
    - prompt:
        play: "say:Press 1 for sales, Press 2 for support"
        max_digits: 1
        speech_hints:
          - one
          - two
    - switch:
        variable: prompt_value
        case:
          '1':
            - execute:
                dest: sales
          '2':
            - execute:
                dest: support
          one:
            - execute:
                dest: sales
          two:
            - execute:
                dest: support
        default:
          - execute:
              dest: sales
  sales:
    - play:
        url: "say:You have reached sales"
    - connect:
        to: "+15551234567"
  support:
    - play:
        url: "say:You have reached support"
    - connect:
        to: "+15551234568"

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "answer": {}
      },
      {
        "play": {
          "url": "say:Welcome to Acme Corporation. This call may be recorded."
        }
      },
      {
        "record_call": {
          "stereo": true,
          "format": "wav"
        }
      },
      {
        "prompt": {
          "play": "say:Press 1 for sales, Press 2 for support",
          "max_digits": 1,
          "speech_hints": [
            "one",
            "two"
          ]
        }
      },
      {
        "switch": {
          "variable": "prompt_value",
          "case": {
            "1": [
              {
                "execute": {
                  "dest": "sales"
                }
              }
            ],
            "2": [
              {
                "execute": {
                  "dest": "support"
                }
              }
            ],
            "one": [
              {
                "execute": {
                  "dest": "sales"
                }
              }
            ],
            "two": [
              {
                "execute": {
                  "dest": "support"
                }
              }
            ]
          },
          "default": [
            {
              "execute": {
                "dest": "sales"
              }
            }
          ]
        }
      }
    ],
    "sales": [
      {
        "play": {
          "url": "say:You have reached sales"
        }
      },
      {
        "connect": {
          "to": "+15551234567"
        }
      }
    ],
    "support": [
      {
        "play": {
          "url": "say:You have reached support"
        }
      },
      {
        "connect": {
          "to": "+15551234568"
        }
      }
    ]
  }
}

```

**Variable substitution**: Notice how `prompt_value` in the switch statement automatically contains the user's input from the prompt. SWML supports dynamic values using the `%{variable_name}` format. For example, you can reference call information with `%{call.from}` or parameters with `%{params.audio_file}`.

## Next steps[​](#next-steps "Direct link to Next steps")

## [Quickstart<!-- -->](/swml/quickstart.md)

[Quickly create and deploy SWML through the SignalWire Dashboard](/swml/quickstart.md)

## [Methods reference<!-- -->](/swml/methods.md)

[Explore all available SWML methods](/swml/methods.md)

## [AI guides<!-- -->](/swml/guides/ai.md)

[Learn how AI methods are used in SWML](/swml/guides/ai.md)


# Quickstart

Deploy your first SWML script in 5 minutes

<br />

<br />

This guide will walk you through deploying your first SWML script to handle incoming calls. By the end of this quickstart, you'll have a working phone number that runs your SWML application.

## Prerequisites[​](#prerequisites "Direct link to Prerequisites")

Before you begin, make sure you have:

* A [SignalWire account](https://signalwire.com/signups/new)
* A SWML script ready for deployment

## Deploy your SWML script[​](#deploy-your-swml-script "Direct link to Deploy your SWML script")

### Create new script[​](#create-new-script "Direct link to Create new script")

From your [SignalWire Dashboard](https://my.signalwire.com), click **Script**, then **SWML script**. This will open the New SWML Script dialog box.

Paste your SWML Script into the Primary Script field, then select **Create**.

If necessary, copy and paste the below example script:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - answer: {}
    - play:
        url: "say:Hello World!"
    - play:
        url: "say:Congratulations on successfully deploying your script!"
    - hangup: {}

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "answer": {}
      },
      {
        "play": {
          "url": "say:Hello World!"
        }
      },
      {
        "play": {
          "url": "say:Congratulations on successfully deploying your script!"
        }
      },
      {
        "hangup": {}
      }
    ]
  }
}

```

Your script will be saved in the "My Resources" section under "Scripts".

It will remain housed here under the name you provide for easy reference.

### Assign a phone number[​](#assign-a-phone-number "Direct link to Assign a phone number")

* Navigate to **Phone Numbers** in your Dashboard.
* Purchase a phone number if needed by clicking the "+ New" button in the top right hand corner of the page.
* Click on your phone number, then click "Edit Settings".
* Click on "+ Assign Resource", then assign your SWML Script.

### Test your application[​](#test-your-application "Direct link to Test your application")

Call your assigned phone number to test your SWML application.

In the Legacy Dashboard

Follow these instructions if your SignalWire Space is on the Legacy Dashboard

You can write and save new SWML scripts from the "RELAY/SWML" section of your Dashboard. In that section, switch to the tab named [SWML Scripts](https://my.signalwire.com/relay-bins). Once there, you can create a new SWML script:

![SignalWire Dashboard with SWML tab open](/assets/images/swml-dashboard-example-37f6ea674d74a47b9a385dc09bf8e9da.webp)

After you save the SWML, navigate to the [Phone Numbers](https://my.signalwire.com/phone_numbers) page. Open the settings for a phone number you own (you may have to buy a new one), and configure it to handle incoming calls using the SWML script you just saved.

![SignalWire Dashboard's phone number setting screen, selecting a SWML script as call handler.](/assets/images/attach-phone-number-vid-3e4c290c9053221fe4907f5799bae0aa.webp)

Learn about the Legacy Dashboard migration

For SignalWire Spaces created before January 2025

Identify your Dashboard and select between Legacy and New UIs using the tabs below.

* New Dashboard
* Legacy Dashboard

![The main sidebar menu of the new SignalWire Space Dashboard UI.](/assets/images/new-sidebar-992f28dd5647abb46d5ae70d8b2b133e.webp)

The redesigned main menu.

![The selection menu when a new Resource is created.](/assets/images/add-new-resource-825099ad2682c3bcfaf1205f843bfaea.webp)

The new SignalWire Dashboard features a streamlined sidebar menu. Many items are now located in the unified My Resources menu.

Resources that were previously accessible in the sidebar of the legacy UI are now located in the unified **My Resources** menu.

![The main sidebar menu of the legacy SignalWire Space Dashboard UI.](/assets/images/sidebar-5828b2f045feb5dda12e9478f6367b3a.webp)

The legacy main menu.

In the Legacy Dashboard, there is no **My Resources** tab.

Instead, Resources are accessible as individual tabs in the main navigational sidebar.

To upgrade your Space to the New UI, [contact Support](https://support.signalwire.com/).

## Next steps[​](#next-steps "Direct link to Next steps")

Now that you've deployed your first SWML script, explore these resources:

## [Methods reference<!-- -->](/swml/methods.md)

[Explore all available SWML methods](/swml/methods.md)

## [SWML AI guides<!-- -->](/swml/guides/ai.md)

[Learn how AI methods are used in SWML](/swml/guides/ai.md)

## [Deployment<!-- -->](/swml/guides/deployment.md)

[Learn about deploying SWML via your own web server](/swml/guides/deployment.md)

## [Agents SDK quickstart<!-- -->](/sdks/agents-sdk/quickstart.md)

[Get started with the AI Agents SDK](/sdks/agents-sdk/quickstart.md)

## [Add funds to account<!-- -->](/platform/dashboard/billing.md#trial-mode)

[Learn how to add funds to your SignalWire account](/platform/dashboard/billing.md#trial-mode)


# Methods overview

Methods in SWML control the program flow and execute functions. This includes setting and unsetting variables, conditional statements, making calls, and sending faxes etc.

## **The `AI` method**[​](#the-ai-method "Direct link to the-ai-method")

The [`ai`](/swml/methods/ai.md) method is an incredibly powerful tool to instantiate an AI agent that holds a natural conversation with the caller, and perform actions based on their input.

## **Control-flow methods**[​](#control-flow-methods "Direct link to control-flow-methods")

### `execute` and `return`[​](#execute-and-return "Direct link to execute-and-return")

The [`execute`](/swml/methods/execute.md) method is similar to a function call in most languages. It can be sent parameters, and it can return values using the [`return`](/swml/methods/return.md) object. The SWML function to be executed can exist as a subsection in the same SWML document, but it can also be a separate SWML document hosted on an internet-accessible web-server.

### `transfer`[​](#transfer "Direct link to transfer")

The [`transfer`](/swml/methods/transfer.md) statement transfers the execution to a different section or a different SWML document. Unlike the `execute` statement, the `transfer` statement doesn't return back to the calling section.

### `goto` and `label`[​](#goto-and-label "Direct link to goto-and-label")

The [`goto`](/swml/methods/goto.md) statement can jump to a specified [`label`](/swml/methods/label.md) either depending on a given condition or unconditionally, and repeatedly for a specified number of repetitions.

### `cond` and `switch`[​](#cond-and-switch "Direct link to cond-and-switch")

The [`cond`](/swml/methods/cond.md) statement is a general purpose conditional branching statement that executes SWML code based on the evaluation of a JavaScript expression.

The [`switch`](/swml/methods/switch.md) statement allows switch-case like conditional execution depending on whether a certain variable is a certain value.

## **Call related methods**[​](#call-related-methods "Direct link to call-related-methods")

### `answer` and `hangup`[​](#answer-and-hangup "Direct link to answer-and-hangup")

Use these methods to decide when to [`answer`](/swml/methods/answer.md) the call and when to [`hangup`](/swml/methods/hangup.md). Some other methods (like [`play`](/swml/methods/play.md)) will automatically answer calls, but you can use these methods to be more specific about when it happens.

### `denoise` and `stop_denoise`[​](#denoise-and-stop_denoise "Direct link to denoise-and-stop_denoise")

The [`denoise`](/swml/methods/denoise.md) method starts the noise reduction filter and the [`stop_denoise`](/swml/methods/stop_denoise.md) method stops it.

### `live_transcribe`[​](#live_transcribe "Direct link to live_transcribe")

The [`live_transcribe`](/swml/methods/live_transcribe.md) method starts a live transcription of the call.

### `live_translate`[​](#live_translate "Direct link to live_translate")

The [`live_translate`](/swml/methods/live_translate.md) method starts a live translation of the call.

### `play` and `prompt`[​](#play-and-prompt "Direct link to play-and-prompt")

The [`play`](/swml/methods/play.md) method can be used to send TTS speech, play audio files, send different rings etc. The [`prompt`](/swml/methods/prompt.md) method also plays TTS or URLs like `play` but it can receive keypad or speech input in response.

### `connect`[​](#connect "Direct link to connect")

Use the [`connect`](/swml/methods/connect.md) method to connect the caller to other phone or SIP calls. You can set it up to dial multiple numbers in series, parallel or a combination of the two.

### `enter_queue`[​](#enter_queue "Direct link to enter_queue")

The [`enter_queue`](/swml/methods/enter_queue.md) method places the call in a queue where it will wait until an agent or resource becomes available. You can configure wait music, timeout settings, and status callbacks to manage the queue experience.

### `join_room`[​](#join_room "Direct link to join_room")

The [`join_room`](/swml/methods/join_room.md) method seamlessly connects your call to a [video room](/video/conference.md), enabling participants to join from various sources, including mobile apps, web browsers, or phone calls.

### `receive_fax`[​](#receive_fax "Direct link to receive_fax")

The [`receive_fax`](/swml/methods/receive_fax.md) method will interpret the call as a fax and process it.

### `record`, `record_call` and `stop_record_call`[​](#record-record_call-and-stop_record_call "Direct link to record-record_call-and-stop_record_call")

The [`record`](/swml/methods/record.md) and the [`record_call`](/swml/methods/record_call.md) methods will record the call. The `record` method, however, waits for the recording to terminate before continuing execution. The [`record_call`](/swml/methods/record_call.md) method starts a call recording in the background, and it stops recording when you call [`stop_record_call`](/swml/methods/stop_record_call.md).

### `tap` and `stop_tap`[​](#tap-and-stop_tap "Direct link to tap-and-stop_tap")

The [`tap`](/swml/methods/tap.md) method starts streaming the call to an RTP or a web socket sink. The [`stop_tap`](/swml/methods/stop_tap.md) method stops it.

### `sip_refer`[​](#sip_refer "Direct link to sip_refer")

The [`sip_refer`](/swml/methods/sip_refer.md) method transfer a SIP call by sending a SIP REFER message.

### `send_sms`[​](#send_sms "Direct link to send_sms")

Use [`send_sms`](/swml/methods/send_sms.md) to send an SMS to a phone number.

### `send_digits`[​](#send_digits "Direct link to send_digits")

Use [`send_digits`](/swml/methods/send_digits.md) to send digits as DTMF tones.


# SWML Variables

Complete reference for variables and scopes in SWML

<br />

<br />

SWML provides a powerful variable system that allows you to access call information, store data, and pass parameters between sections. This page is the authoritative technical reference for global variable scopes (`call`, `params`, `vars`, `envs`) and variable management in SWML.

For information about using JavaScript expressions with variables, see the [Expressions Reference](/swml/expressions.md). For template transformation functions, see the [Template Functions Reference](/swml/reference/template-functions.md).

## Variable syntax[​](#variable-syntax "Direct link to Variable syntax")

SWML uses the `${variable}` syntax for variable substitution:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - play:
        url: 'say: This call is from the number ${call.from}'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "play": {
          "url": "say: This call is from the number ${call.from}"
        }
      }
    ]
  }
}

```

## Variables list[​](#variables-list "Direct link to Variables list")

SWML provides several variable scopes that are available throughout your scripts. These scopes give you access to call information, script parameters, and stored data.

**`call`** (`object`, optional)

Information about the current call. Contains the following properties.

**Scope:** Call-specific and read-only. Each call leg (A-leg, B-leg) has its own unique `call` object with different `call_id`, `from`, `to`, etc. When connecting to a new leg, the `call` object is re-initialized with the new leg's data.

---

**`call.call_id`** (`string`, optional)

A unique identifier for the call.

---

**`call.call_state`** (`string`, optional)

The current state of the call.

---

**`call.direction`** (`string`, optional)

The direction of this call. Possible values: `inbound`, `outbound`

---

**`call.from`** (`string`, optional)

The number/URI that initiated this call.

---

**`call.headers`** (`object[]`, optional)

The headers associated with this call.

---

**`call.headers[].name`** (`string`, optional)

The name of the header.

---

**`call.headers[].value`** (`string`, optional)

The value of the header.

---

**`call.node_id`** (`string`, optional)

A unique identifier for the node handling the call.

---

**`call.project_id`** (`string`, optional)

The Project ID this call belongs to.

---

**`call.segment_id`** (`string`, optional)

A unique identifier for the current call segment.

---

**`call.sip_data`** (`object`, optional)

SIP-specific data for SIP calls. Only present when `call.type` is `sip`. Contains detailed SIP header information.

---

**`call.space_id`** (`string`, optional)

The Space ID this call belongs to.

---

**`call.to`** (`string`, optional)

The number/URI of the destination of this call.

---

**`call.type`** (`string`, optional)

The type of call. Possible values: `sip`, `phone`, `webrtc`

---

**`sip_data.sip_contact_host`** (`string`, optional)

The host portion of the SIP Contact header.

---

**`sip_data.sip_contact_params`** (`object`, optional)

Additional parameters from the SIP Contact header.

---

**`sip_data.sip_contact_port`** (`string`, optional)

The port from the SIP Contact header.

---

**`sip_data.sip_contact_uri`** (`string`, optional)

The full URI from the SIP Contact header.

---

**`sip_data.sip_contact_user`** (`string`, optional)

The user portion of the SIP Contact header.

---

**`sip_data.sip_from_host`** (`string`, optional)

The host portion of the SIP From header.

---

**`sip_data.sip_from_uri`** (`string`, optional)

The full URI from the SIP From header.

---

**`sip_data.sip_from_user`** (`string`, optional)

The user portion of the SIP From header.

---

**`sip_data.sip_req_host`** (`string`, optional)

The host portion of the SIP request URI.

---

**`sip_data.sip_req_uri`** (`string`, optional)

The full SIP request URI.

---

**`sip_data.sip_req_user`** (`string`, optional)

The user portion of the SIP request URI.

---

**`sip_data.sip_to_host`** (`string`, optional)

The host portion of the SIP To header.

---

**`sip_data.sip_to_uri`** (`string`, optional)

The full URI from the SIP To header.

---

**`sip_data.sip_to_user`** (`string`, optional)

The user portion of the SIP To header.

---

**`envs`** (`object`, optional)

Environment variables configured at the account or project level in your SignalWire configuration. These provide access to account-wide settings and configuration values.

Coming soon!

The `envs` object is included in POST request bodies to external servers, but the ability to set environment variables in the SignalWire Dashboard is not yet available in production. This feature is coming soon.

**Scope:** Account/project-level and read-only. Set in your SignalWire account configuration, not within SWML scripts.

**Fallback behavior:** When you reference a variable without a scope prefix (e.g., `${my_variable}`), SWML first checks `vars`. If not found in `vars`, it automatically falls back to `envs`.

**Example keys:** `envs.api_key`, `envs.webhook_url`, `envs.account_setting`

---

**`params`** (`object`, optional)

Parameters that are user-defined and set by the calling the [`execute`](/swml/methods/execute.md) or [`transfer`](/swml/methods/transfer.md) method.

**Scope:** Section-scoped and read-only. Each section has its own independent `params` that must be explicitly passed via `execute` or `transfer`. Params do not persist after a section completes. When an `execute` call returns, the calling section's original params are restored.

**Example keys:** `params.audio_file`, `params.volume`, `params.department`

---

**`vars`** (`object`, optional)

Script variables that can be set, modified, and accessed throughout your SWML script.

**Created by:**

* [`set`](/swml/methods/set.md) method - Create or update user-defined variables
* Method outputs - Many methods automatically create variables (e.g., `prompt_value`, `record_url`, `return_value`)

**Managed with:**

* [`unset`](/swml/methods/unset.md) method - Remove variables

**Example keys:** `vars.user_choice`, `vars.counter`, `vars.prompt_value`, `vars.record_url`

**Scope:** Global within a single call session. Variables persist across all sections and through `execute` calls. However, connecting to a new leg of a call will reset the `vars` object to an empty state.

**Variable access:** Variables can be accessed with or without the `vars.` prefix. When you reference a variable without a scope prefix (e.g., `${my_variable}`), SWML first checks `vars`. If not found in `vars`, it automatically falls back to `envs`.

---

### Example: Variables in JSON format[​](#example-variables-in-json-format "Direct link to Example: Variables in JSON format")

When SWML communicates with your SWML server, the following request body format is used to represent variables:

```json
{
  "call": {
    "call_id": "<CALL_UUID>",
    "node_id": "<NODE_ID>",
    "segment_id": "<SEGMENT_ID>",
    "call_state": "created",
    "direction": "inbound",
    "type": "sip",
    "from": "sip:user@example.com",
    "to": "sip:destination@yourdomain.com",
    "headers": [],
    "sip_data": {
      "sip_req_user": "destination",
      "sip_req_uri": "destination@yourdomain.com",
      "sip_req_host": "yourdomain.com",
      "sip_from_user": "user",
      "sip_from_uri": "user@example.com",
      "sip_from_host": "example.com",
      "sip_to_user": "destination",
      "sip_to_uri": "destination@yourdomain.com",
      "sip_to_host": "yourdomain.com",
      "sip_contact_user": "user",
      "sip_contact_port": "5060",
      "sip_contact_uri": "user@192.168.1.100:5060",
      "sip_contact_host": "192.168.1.100",
      "sip_contact_params": {}
    },
    "project_id": "<YOUR PROJECT ID>",
    "space_id": "<YOUR SPACE ID>"
  },
  "vars": {
    "user_selection": "1"
  },
  "envs": {
    "api_key": "<YOUR_API_KEY>",
    "webhook_url": "https://example.com/webhook"
  },
  "params": {
    "department": "sales"
  }
}

```

## Variables in serverless and server-based SWML[​](#variables-in-serverless-and-server-based-swml "Direct link to Variables in serverless and server-based SWML")

All SWML variables (`call`, `params`, `vars`, `envs`) are available in both serverless (Dashboard-hosted) and server-based (external URL) deployments.

### Serverless (dashboard-hosted) scripts[​](#serverless-dashboard-hosted-scripts "Direct link to Serverless (dashboard-hosted) scripts")

When SWML is executed directly from the SignalWire Dashboard, access variables using the `${}` syntax:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - set:
        department: sales
    - play:
        url: 'say: You are calling from ${call.from}'
    - play:
        url: 'say: Department is ${vars.department}'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "set": {
          "department": "sales"
        }
      },
      {
        "play": {
          "url": "say: You are calling from ${call.from}"
        }
      },
      {
        "play": {
          "url": "say: Department is ${vars.department}"
        }
      }
    ]
  }
}

```

### Server-based (external URL) scripts[​](#server-based-external-url-scripts "Direct link to Server-based (external URL) scripts")

When SWML is served from your web server, SignalWire sends the current variable state as JSON in the POST request body (see the [JSON format example](#example-variables-in-json-format) above).

You have two options for working with these variables in your SWML response:

#### Option 1: Use variable expansion syntax[​](#option-1-use-variable-expansion-syntax "Direct link to Option 1: Use variable expansion syntax")

Use `${}` syntax in your returned SWML, and SignalWire will substitute the values at runtime:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - play:
        url: 'say: Welcome to ${params.department}'
    - play:
        url: 'say: Calling from ${call.from}'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "play": {
          "url": "say: Welcome to ${params.department}"
        }
      },
      {
        "play": {
          "url": "say: Calling from ${call.from}"
        }
      }
    ]
  }
}

```

#### Option 2: Extract and insert values server-side[​](#option-2-extract-and-insert-values-server-side "Direct link to Option 2: Extract and insert values server-side")

Extract variables from the request body in your server code and insert them directly into the SWML response:

```javascript
// Example: Node.js/Express server
app.post('/swml-handler', (req, res) => {
  const { call, vars, envs, params } = req.body;

  // Extract values from the request
  const department = params.department || 'support';
  const callerNumber = call.from;
  const apiKey = envs.api_key;

  // Build SWML with values inserted directly
  const swml = {
    version: '1.0.0',
    sections: {
      main: [
        {
          play: {
            url: `say: Welcome to ${department}`
          }
        },
        {
          play: {
            url: `say: Calling from ${callerNumber}`
          }
        }
      ]
    }
  };

  res.json(swml);
});

```

Both approaches produce the same result. Use variable expansion (`${}`) for simpler cases, or extract values server-side when you need to perform logic or transformations on the data.

See the [Deployment Guide](/swml/guides/deployment.md) for complete server setup instructions.

## Accessing variable data[​](#accessing-variable-data "Direct link to Accessing variable data")

Variables can contain different types of data - simple values, nested objects, or arrays. Use dot notation (`.`) for object properties, bracket notation (`[]`) for array elements, or combine both for complex data structures.

### Simple values[​](#simple-values "Direct link to Simple values")

Access variables directly by name:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - set:
        name: Alice
        age: 30
    - play:
        url: 'say: Hello ${name}, you are ${age} years old'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "set": {
          "name": "Alice",
          "age": 30
        }
      },
      {
        "play": {
          "url": "say: Hello ${name}, you are ${age} years old"
        }
      }
    ]
  }
}

```

### Nested objects[​](#nested-objects "Direct link to Nested objects")

Access nested properties using dot notation:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - set:
        user:
          name: Alice
          address:
            city: Seattle
            state: WA
    - play:
        url: 'say: ${user.name} lives in ${user.address.city}, ${user.address.state}'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "set": {
          "user": {
            "name": "Alice",
            "address": {
              "city": "Seattle",
              "state": "WA"
            }
          }
        }
      },
      {
        "play": {
          "url": "say: ${user.name} lives in ${user.address.city}, ${user.address.state}"
        }
      }
    ]
  }
}

```

### Arrays[​](#arrays "Direct link to Arrays")

Access array elements using bracket notation with zero-based indexing:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - set:
        departments:
          - Sales
          - Support
          - Engineering
    - play:
        url: 'say: First department is ${departments[0]}'
    - play:
        url: 'say: Second department is ${departments[1]}'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "set": {
          "departments": [
            "Sales",
            "Support",
            "Engineering"
          ]
        }
      },
      {
        "play": {
          "url": "say: First department is ${departments[0]}"
        }
      },
      {
        "play": {
          "url": "say: Second department is ${departments[1]}"
        }
      }
    ]
  }
}

```

### Arrays of objects[​](#arrays-of-objects "Direct link to Arrays of objects")

Combine bracket and dot notation to access properties in array elements:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - set:
        employees:
          - name: Alice
            role: Engineer
          - name: Bob
            role: Manager
    - play:
        url: 'say: ${employees[0].name} is an ${employees[0].role}'
    - play:
        url: 'say: ${employees[1].name} is a ${employees[1].role}'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "set": {
          "employees": [
            {
              "name": "Alice",
              "role": "Engineer"
            },
            {
              "name": "Bob",
              "role": "Manager"
            }
          ]
        }
      },
      {
        "play": {
          "url": "say: ${employees[0].name} is an ${employees[0].role}"
        }
      },
      {
        "play": {
          "url": "say: ${employees[1].name} is a ${employees[1].role}"
        }
      }
    ]
  }
}

```
# SWML Template Functions

Reference for built-in transformation functions

<br />

<br />

Template functions provide simple text transformations for common operations like converting to lowercase, URL encoding, and date formatting. They complement JavaScript expressions by handling specific formatting tasks that don't require complex logic.

For information about variable scopes, see the [Variables Reference](/swml/variables.md). For JavaScript expressions and data manipulation, see the [Expressions Reference](/swml/expressions.md).

caution

Template functions are **only** available in [SWAIG (SignalWire AI Gateway)](/swml/methods/ai/swaig.md) contexts, specifically within:

* AI function `data_map` processing (expressions, webhooks, output)
* Webhook responses to SWAIG functions
* AI prompt variable expansion

They are **not** available in regular SWML methods or general variable contexts. For regular SWML variable manipulation, use JavaScript expressions with the `${expression}` syntax instead.

## Available template functions[​](#available-template-functions "Direct link to Available template functions")

**`lc`** (`string`, optional)

Converts a string to lowercase. Commonly used to normalize user input for case-insensitive comparisons or ensure consistent casing when accessing object properties dynamically.

**Syntax:** `${lc:<value>}`

**Example:**

* YAML
* JSON

```yaml
SWAIG:
  functions:
    - function: lookup
      description: Look up department contact
      parameters:
        type: object
        properties:
          department:
            type: string
            description: Department name from user
      data_map:
        expressions:
          - string: '${meta_data.contacts.${lc:args.department}}'
            pattern: '\w+'
            output:
              response: "Found contact for ${args.department}"
      meta_data:
        contacts:
          sales: '+12025551234'
          support: '+12025555678'

```

```yaml
{
  "SWAIG": {
    "functions": [
      {
        "function": "lookup",
        "description": "Look up department contact",
        "parameters": {
          "type": "object",
          "properties": {
            "department": {
              "type": "string",
              "description": "Department name from user"
            }
          }
        },
        "data_map": {
          "expressions": [
            {
              "string": "${meta_data.contacts.${lc:args.department}}",
              "pattern": "\\w+",
              "output": {
                "response": "Found contact for ${args.department}"
              }
            }
          ]
        },
        "meta_data": {
          "contacts": {
            "sales": "+12025551234",
            "support": "+12025555678"
          }
        }
      }
    ]
  }
}

```

---

**`enc:url`** (`string`, optional)

Encodes a string for safe use in URLs by converting special characters to percent-encoded equivalents. Always use this when including variables in URL query parameters or paths to prevent special characters from breaking URLs or causing unexpected behavior.

**Syntax:** `${enc:url:<value>}`

**Example:**

* YAML
* JSON

```yaml
SWAIG:
  functions:
    - function: search
      description: Search external knowledge base
      parameters:
        type: object
        properties:
          query:
            type: string
            description: User's search query
      data_map:
        webhooks:
          - url: 'https://api.example.com/search?q=${enc:url:args.query}'
            method: GET
            output:
              response: "Found ${results.total} results for ${args.query}"

```

```yaml
{
  "SWAIG": {
    "functions": [
      {
        "function": "search",
        "description": "Search external knowledge base",
        "parameters": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "User's search query"
            }
          }
        },
        "data_map": {
          "webhooks": [
            {
              "url": "https://api.example.com/search?q=${enc:url:args.query}",
              "method": "GET",
              "output": {
                "response": "Found ${results.total} results for ${args.query}"
              }
            }
          ]
        }
      }
    ]
  }
}

```

---

**`strftime_tz`** (`string`, optional)

Formats the current date and time using standard strftime format codes with timezone support. This generates timestamps at the moment the template is evaluated, not when the SWML script was created.

**Syntax:** `@{strftime_tz <timezone> <format>}`

**Common format codes:**

* `%Y-%m-%d` - ISO date (2025-01-15)
* `%H:%M:%S` - 24-hour time (14:30:45)
* `%I:%M %p` - 12-hour time (02:30 PM)
* `%A, %B %d, %Y` - Full readable date (Monday, January 15, 2025)

**Example:**

* YAML
* JSON

```yaml
SWAIG:
  functions:
    - function: log_call
      description: Log call details with timestamp
      data_map:
        webhooks:
          - url: 'https://api.example.com/logs'
            method: POST
            params:
              timestamp: '@{strftime_tz America/Chicago %Y-%m-%d %H:%M:%S}'
              call_id: '${call.call_id}'
              from: '${call.from}'
            output:
              response: "Call logged successfully"

```

```yaml
{
  "SWAIG": {
    "functions": [
      {
        "function": "log_call",
        "description": "Log call details with timestamp",
        "data_map": {
          "webhooks": [
            {
              "url": "https://api.example.com/logs",
              "method": "POST",
              "params": {
                "timestamp": "@{strftime_tz America/Chicago %Y-%m-%d %H:%M:%S}",
                "call_id": "${call.call_id}",
                "from": "${call.from}"
              },
              "output": {
                "response": "Call logged successfully"
              }
            }
          ]
        }
      }
    ]
  }
}

```

---

**`fmt_ph`** (`string`, optional)

Formats a phone number using specified international format standards. Supports multiple format types for different use cases, with optional separators for improved text-to-speech pronunciation.

**Syntax:** `@{fmt_ph <format> <phone_number>}` or `@{fmt_ph <format>:sep:<separator> <phone_number>}`

**Available formats:**

* `national` - National format (default)
* `international` - International format with country code
* `RFC3966` - RFC 3966 format (tel: URI)
* `e164` - E.164 format (+1234567890)

**Example:**

* YAML
* JSON

```yaml
SWAIG:
  functions:
    - function: format_number
      description: Format phone number for speech
      data_map:
        output:
          response: |
            International format: @{fmt_ph international ${call.from}}
            Spaced format: @{fmt_ph national:sep:- ${call.from}}

```

```yaml
{
  "SWAIG": {
    "functions": [
      {
        "function": "format_number",
        "description": "Format phone number for speech",
        "data_map": {
          "output": {
            "response": "International format: @{fmt_ph international ${call.from}}\nSpaced format: @{fmt_ph national:sep:- ${call.from}}\n"
          }
        }
      }
    ]
  }
}

```

---

**`expr`** (`string`, optional)

Evaluates simple arithmetic expressions with literal numbers. Supports addition, subtraction, multiplication, division, and parentheses for grouping. Only works with literal numbers and cannot reference variables.

**Syntax:** `@{expr <expression>}`

**Example:**

* YAML
* JSON

```yaml
SWAIG:
  functions:
    - function: calculate_discount
      description: Calculate discount amount
      data_map:
        output:
          response: "The discount is @{expr (100 - 25) / 5} dollars"

```

```yaml
{
  "SWAIG": {
    "functions": [
      {
        "function": "calculate_discount",
        "description": "Calculate discount amount",
        "data_map": {
          "output": {
            "response": "The discount is @{expr (100 - 25) / 5} dollars"
          }
        }
      }
    ]
  }
}

```

---

**`echo`** (`string`, optional)

Returns the argument unchanged. Primarily useful for debugging template evaluation or forcing explicit variable expansion in complex nested scenarios.

**Syntax:** `@{echo <text>}`

**Example:**

* YAML
* JSON

```yaml
SWAIG:
  functions:
    - function: debug_value
      description: Debug template evaluation
      parameters:
        type: object
        properties:
          input:
            type: string
            description: Value to debug
      data_map:
        output:
          response: "Debug value: @{echo ${args.input}}"

```

```yaml
{
  "SWAIG": {
    "functions": [
      {
        "function": "debug_value",
        "description": "Debug template evaluation",
        "parameters": {
          "type": "object",
          "properties": {
            "input": {
              "type": "string",
              "description": "Value to debug"
            }
          }
        },
        "data_map": {
          "output": {
            "response": "Debug value: @{echo ${args.input}}"
          }
        }
      }
    ]
  }
}

```

---

**`separate`** (`string`, optional)

Inserts spaces between each character in a string to improve text-to-speech pronunciation. Particularly useful for spelling out confirmation codes, license plates, serial numbers, or any text that should be read character-by-character.

**Syntax:** `@{separate <text>}`

**Example:**

* YAML
* JSON

```yaml
SWAIG:
  functions:
    - function: spell_code
      description: Spell out confirmation code
      parameters:
        type: object
        properties:
          code:
            type: string
            description: Confirmation code to spell
      data_map:
        output:
          response: "Your code is @{separate ${args.code}}"

```

```yaml
{
  "SWAIG": {
    "functions": [
      {
        "function": "spell_code",
        "description": "Spell out confirmation code",
        "parameters": {
          "type": "object",
          "properties": {
            "code": {
              "type": "string",
              "description": "Confirmation code to spell"
            }
          }
        },
        "data_map": {
          "output": {
            "response": "Your code is @{separate ${args.code}}"
          }
        }
      }
    ]
  }
}

```

In this example, if `code` is "ABC123", the AI will pronounce "A B C 1 2 3" instead of trying to say "ABC123" as a word.

---

**`sleep`** (`string`, optional)

Pauses execution for the specified number of seconds. Can be used for rate limiting, timing coordination, or testing purposes.

**Syntax:** `@{sleep <seconds>}`

caution

Use sparingly in production environments. Excessive delays can cause timeouts, impact call quality, and degrade user experience. Best suited for development, testing, or specific rate-limiting scenarios.

**Example:**

* YAML
* JSON

```yaml
SWAIG:
  functions:
    - function: delayed_task
      description: Execute with delay for rate limiting
      data_map:
        output:
          response: "Executed after @{sleep 2} second delay"

```

```yaml
{
  "SWAIG": {
    "functions": [
      {
        "function": "delayed_task",
        "description": "Execute with delay for rate limiting",
        "data_map": {
          "output": {
            "response": "Executed after @{sleep 2} second delay"
          }
        }
      }
    ]
  }
}

```

---

## Function chaining[​](#function-chaining "Direct link to Function chaining")

Prefix functions (using `${...}` syntax) can be chained together to apply multiple transformations in sequence. The transformations are applied from left to right.

**Syntax:** `${func1:func2:func3:<value>}`

**Example:**

* YAML
* JSON

```yaml
SWAIG:
  functions:
    - function: search
      description: Search external knowledge base
      parameters:
        type: object
        properties:
          query:
            type: string
            description: User's search query
      data_map:
        webhooks:
          # First converts to lowercase, then URL encodes
          - url: 'https://api.example.com/search?q=${lc:enc:url:args.query}'
            method: GET
            output:
              response: "Found results for ${args.query}"

```

```yaml
{
  "SWAIG": {
    "functions": [
      {
        "function": "search",
        "description": "Search external knowledge base",
        "parameters": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "User's search query"
            }
          }
        },
        "data_map": {
          "webhooks": [
            {
              "url": "https://api.example.com/search?q=${lc:enc:url:args.query}",
              "method": "GET",
              "output": {
                "response": "Found results for ${args.query}"
              }
            }
          ]
        }
      }
    ]
  }
}

```

## Full example[​](#full-example "Direct link to Full example")

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - answer: {}
    - ai:
        prompt:
          text: |
            You help users access department resources.
            When they specify a department, use the lookup function.
        SWAIG:
          functions:
            - function: lookup
              description: Look up department contact
              parameters:
                type: object
                properties:
                  department:
                    type: string
                    description: Department name from user
              data_map:
                expressions:
                  - string: '${meta_data.contacts.${lc:args.department}}'
                    pattern: '\w+'
                    output:
                      response: "Found contact for ${args.department}"
              meta_data:
                contacts:
                  sales: '+12025551234'
                  support: '+12025555678'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "answer": {}
      },
      {
        "ai": {
          "prompt": {
            "text": "You help users access department resources.\nWhen they specify a department, use the lookup function.\n"
          },
          "SWAIG": {
            "functions": [
              {
                "function": "lookup",
                "description": "Look up department contact",
                "parameters": {
                  "type": "object",
                  "properties": {
                    "department": {
                      "type": "string",
                      "description": "Department name from user"
                    }
                  }
                },
                "data_map": {
                  "expressions": [
                    {
                      "string": "${meta_data.contacts.${lc:args.department}}",
                      "pattern": "\\w+",
                      "output": {
                        "response": "Found contact for ${args.department}"
                      }
                    }
                  ]
                },
                "meta_data": {
                  "contacts": {
                    "sales": "+12025551234",
                    "support": "+12025555678"
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}

```




# SWML Expressions

Reference for using JavaScript expressions in SWML

<br />

<br />

Expressions allow you to use JavaScript within SWML variables to transform data, perform calculations, and implement logic. Instead of static values, you can dynamically construct values based on call data, user input, and calculations.

For information about variable scopes and basic access patterns, see the [Variables Reference](/swml/variables.md). For template transformation functions, see the [Template Functions Reference](/swml/reference/template-functions.md).

## What are expressions?[​](#what-are-expressions "Direct link to What are expressions?")

Expressions use the `${...}` syntax and support JavaScript for dynamic value construction. Any JavaScript that evaluates to a value can be used inside these delimiters. Both syntaxes work identically.

SWML uses the Google V8 JavaScript engine (version 6 and later) to evaluate expressions. For detailed JavaScript feature support, refer to the [V8 documentation](https://v8.dev/docs).

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - prompt:
        play: 'say: Please enter your order quantity'
        speech_hints:
          - one
          - two
          - three
    - set:
        # Set the prompt value
        quantity: '${prompt_value}'
        # Set the unit price
        unit_price: 5
        # Extract area code from caller
        area_code: '${call.from.substring(0, 3)}'
        # Calculate total with tax
        subtotal: '${vars.unit_price * parseInt(vars.quantity)}'
        tax: '${subtotal * 0.08}'
        total: '${subtotal + tax}'
        # Determine shipping message
        shipping_msg: '${total > 50 ? "with free shipping" : "plus shipping"}'
    - play:
        url: 'say: Your total is ${total.toFixed(2)} dollars ${shipping_msg}'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "prompt": {
          "play": "say: Please enter your order quantity",
          "speech_hints": [
            "one",
            "two",
            "three"
          ]
        }
      },
      {
        "set": {
          "quantity": "${prompt_value}",
          "unit_price": 5,
          "area_code": "${call.from.substring(0, 3)}",
          "subtotal": "${vars.unit_price * parseInt(vars.quantity)}",
          "tax": "${subtotal * 0.08}",
          "total": "${subtotal + tax}",
          "shipping_msg": "${total > 50 ? \"with free shipping\" : \"plus shipping\"}"
        }
      },
      {
        "play": {
          "url": "say: Your total is ${total.toFixed(2)} dollars ${shipping_msg}"
        }
      }
    ]
  }
}

```

Expressions are evaluated at runtime and replaced with their computed values.

### Variable access in expressions[​](#variable-access-in-expressions "Direct link to Variable access in expressions")

All SWML variables are accessible within JavaScript expressions. You can reference them with or without scope prefixes:

```yaml
- set:
    # With prefix (explicit)
    caller: '${call.from}'
    value: '${vars.my_variable}'
    setting: '${envs.api_key}'
    # Without prefix (automatic)
    formatted: '${my_variable.toUpperCase()}'

```

When you access a variable without a prefix, the expression engine checks scopes in this order: `vars`, then `envs`, then `call`. Using explicit prefixes like `vars.` or `call.` is recommended for clarity, especially when variable names might exist in multiple scopes.

## When to use expressions vs. server-side logic[​](#when-to-use-expressions-vs-server-side-logic "Direct link to When to use expressions vs. server-side logic")

Expressions are evaluated at runtime within SWML and work well for simple transformations like formatting phone numbers or calculating totals. The question of when to use expressions versus server-side logic depends largely on your deployment model.

### Serverless (dashboard-hosted) SWML[​](#serverless-dashboard-hosted-swml "Direct link to Serverless (dashboard-hosted) SWML")

When hosting SWML directly in the SignalWire Dashboard, expressions become your primary tool for dynamic behavior. You can use them to transform call data like extracting area codes with `${call.from.substring(0, 3)}`, perform calculations such as `${vars.unit_price * parseInt(vars.quantity)}`, or make simple decisions with ternary operators.

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - prompt:
        play: 'say: Please enter your order quantity'
        speech_hints:
          - one
          - two
          - three
    - set:
        # Set the prompt value
        quantity: '${prompt_value}'
        # Set the unit price
        unit_price: 5
        # Extract area code from caller
        area_code: '${call.from.substring(0, 3)}'
        # Calculate total with tax
        subtotal: '${vars.unit_price * parseInt(vars.quantity)}'
        tax: '${subtotal * 0.08}'
        total: '${subtotal + tax}'
        # Determine shipping message
        shipping_msg: '${total > 50 ? "with free shipping" : "plus shipping"}'
    - play:
        url: 'say: Your total is ${total.toFixed(2)} dollars ${shipping_msg}'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "prompt": {
          "play": "say: Please enter your order quantity",
          "speech_hints": [
            "one",
            "two",
            "three"
          ]
        }
      },
      {
        "set": {
          "quantity": "${prompt_value}",
          "unit_price": 5,
          "area_code": "${call.from.substring(0, 3)}",
          "subtotal": "${vars.unit_price * parseInt(vars.quantity)}",
          "tax": "${subtotal * 0.08}",
          "total": "${subtotal + tax}",
          "shipping_msg": "${total > 50 ? \"with free shipping\" : \"plus shipping\"}"
        }
      },
      {
        "play": {
          "url": "say: Your total is ${total.toFixed(2)} dollars ${shipping_msg}"
        }
      }
    ]
  }
}

```

If you need complex logic in serverless mode, use the [`request`](/swml/methods/request.md) method to fetch data from a server during call execution. The response data becomes available as variables that you can then manipulate with expressions.

### Server-based (external URL) SWML[​](#server-based-external-url-swml "Direct link to Server-based (external URL) SWML")

Serving SWML from your own web server opens up more architectural options. This is where you should handle database queries, external API calls to your business systems, and any complex business logic that requires authentication or heavy data processing.

The general pattern is to do the heavy lifting server-side before generating the SWML response, then use expressions for runtime transformations. For example, you might query your database to fetch customer information, call your internal billing service to get their account status, and insert that data directly into the SWML. Then expressions handle runtime concerns like formatting that data or calculating values based on user input collected during the call.

```javascript
app.post('/swml-handler', async (req, res) => {
  const { call, params } = req.body;

  // Server-side: Query database
  const customer = await db.query(
    'SELECT * FROM customers WHERE phone = ?',
    [call.from]
  );

  // Server-side: Call internal billing API
  const billing = await fetch(`https://billing.yourcompany.com/api/account/${customer.id}`);
  const accountData = await billing.json();

  // Return SWML with data inserted
  const swml = {
    version: '1.0.0',
    sections: {
      main: [
        {
          play: {
            // Expression: Simple transformation at runtime
            url: `say: Hello ${customer.name}, your account status is ${accountData.status}`
          }
        },
        {
          set: {
            // Expression: Calculate with fetched data
            discount: '${params.base_price * 0.1}'
          }
        }
      ]
    }
  };

  res.json(swml);
});

```

The key principle is to use server-side logic to prepare and fetch data, then use expressions for transformations and dynamic behavior that happen during the call itself.

## Common expression patterns[​](#common-expression-patterns "Direct link to Common expression patterns")

### String operations[​](#string-operations "Direct link to String operations")

Transform and manipulate text using JavaScript string methods:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - set:
        first_name: 'John'
        last_name: 'Doe'
        # Extract part of a string
        area_code: '${call.from.substring(0, 3)}'
        # Change case
        uppercase: '${call.type.toUpperCase()}'
        # Combine strings
        full_name: '${vars.first_name + " " + vars.last_name}'
    - play:
        url: 'say: Hello ${full_name}. Your area code is ${area_code}. Call type: ${uppercase}'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "set": {
          "first_name": "John",
          "last_name": "Doe",
          "area_code": "${call.from.substring(0, 3)}",
          "uppercase": "${call.type.toUpperCase()}",
          "full_name": "${vars.first_name + \" \" + vars.last_name}"
        }
      },
      {
        "play": {
          "url": "say: Hello ${full_name}. Your area code is ${area_code}. Call type: ${uppercase}"
        }
      }
    ]
  }
}

```

Common methods: `substring()`, `toUpperCase()`, `toLowerCase()`, `trim()`, `replace()`, `split()`, `join()`

### Arithmetic and math[​](#arithmetic-and-math "Direct link to Arithmetic and math")

Perform calculations using standard JavaScript operators and Math functions:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - set:
        # Calculate total
        total: '${params.price * params.quantity}'
        # Format currency (2 decimal places)
        formatted: '${total.toFixed(2)}'
        # Round to nearest integer
        rounded: '${Math.round(params.rating)}'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "set": {
          "total": "${params.price * params.quantity}",
          "formatted": "${total.toFixed(2)}",
          "rounded": "${Math.round(params.rating)}"
        }
      }
    ]
  }
}

```

Use operators: `+`, `-`, `*`, `/`, `%` and Math functions: `Math.round()`, `Math.ceil()`, `Math.floor()`, `Math.max()`, `Math.min()`

### Conditional logic[​](#conditional-logic "Direct link to Conditional logic")

Use ternary operators and comparisons to make decisions:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
    - set:
        # Conditional greeting based on call direction
        greeting: '${call.direction == "inbound" ? "Welcome" : "Calling"}'
        # Fallback to "unknown" if call.type is null
        call_label: '${call.type != null ? call.type : "unknown"}'
        # Compound condition checking both type and direction
        status: '${call.type == "phone" && call.direction == "inbound" ? "valid" : "invalid"}'
    - play:
        url: 'say: ${greeting}! Your call type is ${call_label} and status is ${status}' 

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "set": {
          "greeting": "${call.direction == \"inbound\" ? \"Welcome\" : \"Calling\"}",
          "call_label": "${call.type != null ? call.type : \"unknown\"}",
          "status": "${call.type == \"phone\" && call.direction == \"inbound\" ? \"valid\" : \"invalid\"}"
        }
      },
      {
        "play": {
          "url": "say: ${greeting}! Your call type is ${call_label} and status is ${status}"
        }
      }
    ]
  }
}

```

Use comparisons: `==`, `!=`, `>`, `<`, `>=`, `<=` and logical operators: `&&`, `||`

### Array operations[​](#array-operations "Direct link to Array operations")

Work with arrays using JavaScript array methods:

* YAML
* JSON

```yaml
  version: 1.0.0
  sections:
    main:
      - set:
          # Define the array first
          items:
            - apple
            - banana
      - set:
          # Get array length
          count: '${(items.length)}'
          # Join array into string
          list: '${vars.items.join(", ")}'
          # Check if array contains item
          has_item: '${vars.items.includes("apple")}'
          # Get last item
          last: '${vars.items[vars.items.length - 1]}'
      - play:
          url: 'say: You have ${count} items: ${list}. Last item is ${last}.'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "set": {
          "items": [
            "apple",
            "banana"
          ]
        }
      },
      {
        "set": {
          "count": "${(items.length)}",
          "list": "${vars.items.join(\", \")}",
          "has_item": "${vars.items.includes(\"apple\")}",
          "last": "${vars.items[vars.items.length - 1]}"
        }
      },
      {
        "play": {
          "url": "say: You have ${count} items: ${list}. Last item is ${last}."
        }
      }
    ]
  }
}

```

Common methods: `.length`, `.join()`, `.includes()`, bracket notation for access

### Type conversions[​](#type-conversions "Direct link to Type conversions")

Convert between strings, numbers, and booleans:

* YAML
* JSON

```yaml
version: 1.0.0
sections:
  main:
  - set:
      quantity: ${parseInt("42")}
      count: 100
      text: "${count.toString()}"
      is_active: "${Boolean(1)}"
  - play:
      url: 'say: The quantity is ${quantity}. The count variable is ${text}. Active is set to ${is_active}'

```

```yaml
{
  "version": "1.0.0",
  "sections": {
    "main": [
      {
        "set": {
          "quantity": "${parseInt(\"42\")}",
          "count": 100,
          "text": "${count.toString()}",
          "is_active": "${Boolean(1)}"
        }
      },
      {
        "play": {
          "url": "say: The quantity is ${quantity}. The count variable is ${text}. Active is set to ${is_active}"
        }
      }
    ]
  }
}

```

Use: `parseInt()`, `parseFloat()`, `.toString()`, `Boolean()`

## Expression limitations[​](#expression-limitations "Direct link to Expression limitations")

Expressions are designed for quick data transformations during calls. They work great for formatting strings, performing calculations, and making simple decisions, but they're intentionally constrained to keep your calls running smoothly.

You can't create custom functions with the `function` keyword or arrow syntax. Instead, rely on JavaScript's built-in methods like string operations, Math functions, and array methods:

```yaml
# This won't work
- set:
    calculator: '${function(x) { return x * 2; }}'

# Do this instead
- set:
    doubled: '${value * 2}'

```

Loops like `for` and `while` aren't available, but you can use array methods for most transformation needs. Methods like `.map()`, `.filter()`, and `.reduce()` handle common iteration patterns:

```yaml
# Loops aren't supported
- set:
    result: '${for(let i=0; i<10; i++) { sum += i; }}'

# Array methods work well
- set:
    sum: '${[1,2,3,4,5].reduce((a,b) => a+b, 0)}'

```

Simple property access like `.length`, `.name`, `.value`, etc. on arrays or strings require parentheses to evaluate correctly. Without them, the expression is treated as a variable lookup rather than JavaScript. Method Calls with parentheses work directly:

```yaml
  # Property access needs parentheses
  - set:
      count: '${(items.length)}'
      name_length: '${(user.name.length)}'

  # Method calls work without extra syntax
  - set:
      list: '${items.join(", ")}'
      upper: '${name.toUpperCase()}'

```

Expressions execute synchronously, so you can't use `async`, `await`, or make API calls directly. For operations that need external data, use the [`request`](/swml/methods/request.md) method to fetch data first, then transform the results with expressions.

Keep expressions under 1,024 characters and expect them to complete within 150ms. If you're hitting these limits, it's usually a sign that the logic belongs in your server code rather than inline in SWML.
